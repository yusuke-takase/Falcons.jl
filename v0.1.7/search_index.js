var documenterSearchIndex = {"docs":
[{"location":"Mapmake/#Mapmake","page":"Mapmake","title":"Mapmake","text":"","category":"section"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"Mapmaking is available for computing hitmap and crosslink maps.","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"ScanningStrategy2map(ss::ScanningStrategy, division::Int)","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"This function splits the observation time specified by ScanningStrategy by the number specified by division, calculates the pointing TOD, and then creates a map using it. The reason for the split calculation is to avoid overloading the memory by calculating a huge amount of pointing TOD data at once. Inside this function, get_pointing_pixels() is being executed.","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"For example,","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"outmap = ScanningStrategy2map(ss::ScanningStrategy, 12)","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"Now, the pointing TOD is calculated every month and stored in the map each time.","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"The outmap is a matrix, the contents of which are as follows.","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"outmap[1]: Hitmap\noutmap[2]: Crosslink map (n=1)\noutmap[3]: Crosslink map (n=2)\noutmap[4]: Crosslink map (n=3)\noutmap[5]: Crosslink map (n=4)","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"The crosslink X_n is represented by the following equation","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"$","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"Xn = \\left[ \\left(\\frac{\\sum^{N{hits}}i{\\sin{(n\\psii)}}}{N{hits}} \\right)^2 + \\left( \\frac{\\sum^{N{hits}}i{\\cos{(n\\psii)}}}{N{hits}}\\right)^2 \\right]     = \\langle \\sin(n\\psii) \\rangle^2 + \\langle \\cos(n\\psi_i) \\rangle^2 $","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"The subscript i indicates that this is the i-th time series data within a certain pixel, and   indicates that the average should be taken.","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"The n is the spin, a measure to define the scan-derived systematic effect. It is described in detail in this paper.","category":"page"},{"location":"Mapmake/#Crosslink-with-half-wave-plate","page":"Mapmake","title":"Crosslink with half-wave plate","text":"","category":"section"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"The next generation of CMB polarimetry satellites, such as LiteBIRD, will be equipped with a half-wave plate(HWP). Falcons is also possible to create a crosslink map that takes into account the optical axis of the HWP. The crosslink with HWP is calculated by the following equation $ X_n^{w/ HWP}=<\\sin(4\\rho-n\\psi)>^2+<\\cos(4\\rho-n\\psi)>^2 . $","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/#Mapmake","page":"-","title":"Mapmake","text":"","category":"section"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"Mapmaking is available for computing hitmap and crosslink maps.","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"ScanningStrategy2map(ss::ScanningStrategy, division::Int)","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"This function splits the observation time specified by ScanningStrategy by the number specified by division, calculates the pointing TOD, and then creates a map using it. The reason for the split calculation is to avoid overloading the memory by calculating a huge amount of pointing TOD data at once. Inside this function, get_pointing_pixels() is being executed.","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"For example,","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"outmap = ScanningStrategy2map(ss::ScanningStrategy, 12)","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"Now, the pointing TOD is calculated every month and stored in the map each time.","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"The outmap is a matrix, the contents of which are as follows.","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"outmap[1]: Hitmap\noutmap[2]: Crosslink map (n=1)\noutmap[3]: Crosslink map (n=2)\noutmap[4]: Crosslink map (n=3)\noutmap[5]: Crosslink map (n=4)","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"The crosslink X_n is represented by the following equation","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"$","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"Xn = \\left[ \\left(\\frac{\\sum^{N{hits}}i{\\sin{(n\\psii)}}}{N{hits}} \\right)^2 + \\left( \\frac{\\sum^{N{hits}}i{\\cos{(n\\psii)}}}{N{hits}}\\right)^2 \\right]     = \\langle \\sin(n\\psii) \\rangle^2 + \\langle \\cos(n\\psi_i) \\rangle^2 $","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"The subscript i indicates that this is the i-th time series data within a certain pixel, and   indicates that the average should be taken.","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"The n is the spin, a measure to define the scan-derived systematic effect. It is described in detail in this paper.","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/#Crosslink-with-half-wave-plate","page":"-","title":"Crosslink with half-wave plate","text":"","category":"section"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"The next generation of CMB polarimetry satellites, such as LiteBIRD, will be equipped with a half-wave plate(HWP). Falcons is also possible to create a crosslink map that takes into account the optical axis of the HWP. The crosslink with HWP is calculated by the following equation $ X_n^{w/ HWP}=<\\sin(4\\rho-n\\psi)>^2+<\\cos(4\\rho-n\\psi)>^2 . $","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/#Falcons","page":"Falcons","title":"Falcons","text":"","category":"section"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"Falcons","title":"Falcons","text":"This is the documentation of Falcons(Fast Algorithm for Locus Computing ON the Sky), a package for fast simulation of satellite observations.","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"Falcons","title":"Falcons","text":"CMB polarimetric satellites such as LiteBIRD set up an appropriate scan strategy to reduce systematic errors, and Falcons can calculate all-sky hit maps, crosslink maps, etc. by simply setting the parameters of this scan strategy. It also supports observations with multi-channel detectors.","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/#Installation","page":"Falcons","title":"Installation","text":"","category":"section"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"Falcons","title":"Falcons","text":"From the Julia REPL, run","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"Falcons","title":"Falcons","text":"import Pkg\nPkg.add(\"Falcons\")","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/#Tutorial","page":"Falcons","title":"Tutorial","text":"","category":"section"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"Falcons","title":"Falcons","text":"The tutorial is available on the github page in jupyternotebook format. Please refer to here.","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/#Documentation","page":"Falcons","title":"Documentation","text":"","category":"section"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"Falcons","title":"Falcons","text":"The documentation was built using Documenter.jl.","category":"page"},{"location":"Scanning/#Scanning-strategy","page":"Scanning","title":"Scanning strategy","text":"","category":"section"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"To define the scanning strategy for a satellite, set the ScanningStrategy structure.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"mutable struct ScanningStrategy{T<:AbstractFloat, I<:Int, AA<:AbstractArray{T}, AS<:AbstractString}\n    nside::I\n    duration::I\n    sampling_rate::I\n    alpha::T\n    beta::T\n    prec_rpm::T\n    spin_rpm::T\n    hwp_rpm::T\n    FP_theta::AA\n    FP_phi::AA\n    start_point::AS\nend","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"You can generate ScanningStrategy structure using gen_ScanningStrategy() function.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"This initial value of component of ScanningStrategy can be changed by specifying the gen_ScanningStrategy() argument when declaring ss like below.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"ss = gen_ScanningStrategy(alpha=60, prec_rpm=0.001, sampling_rate=5)","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"In addition, you can directly access ss and interactively change its value.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"ss.nside = 256 #You can change a value\nss.spin_rpm = 0.04","category":"page"},{"location":"Scanning/#Generate-pointing-TOD","page":"Scanning","title":"Generate pointing TOD","text":"","category":"section"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"The information about the orientation of a satellite at a certain time is called pointing. The pointing is defined by (theta phi psi), where theta and phi are parameters of the 3D polar coordinates and psi is the angle between the scan direction and the meridian of the sky.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"Once the scanning strategy is determined, computing the pointing is straightforward.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"pointings = get_pointings(ss::ScanningStrategy, start::Int, stop::Int)\npix_tod, psi_tod, time_array = get_pointing_pixels(ss::ScanningStrategy, start::Int, stop::Int)","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"Enter an integer value for the time to be calculated in the start and stop fields. The get_pointings() returns (theta phi psi) that indicate their pointing in chronological order. These are stored as an array of dictionary type, and can be accessed as follows.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"In[]: pointings[\"theta\"]\nOut[]: 14400×1 Matrix{Float64}:\n 1.1344640137963142\n 1.134461356131033\n 1.1344533831585348\n 1.1344400949488544\n...","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"The pointings[\"psi\"] contains the scanning angle according to the COSMO(HEALPix) definition. And pointings[\"time\"] contains the time used in the calculation.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"The get_pointing_pixels() does not allocate theta and phi arrays internally, but only allocates the minimum number of arrays needed to allocate the pixel TOD. Therefore, it runs faster than get_pointings(). In fact, get_pointing_pixels() is executed inside ScanningStrategy2map().","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"Now, the pointing TOD is calculated every month and stored in the map each time.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"ss.FP_theta = [0.0, 10.0]\nss.FP_phi = [0.0, 90.0]","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"In this operation, the first component of the array represents the center of the focal plane, i.e. the boresight. On the other hand, the second component represents the detector that observes a point in the sky 10 degrees in theta direction and 90 degrees in phi direction away from the boresight.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"If you want to build a focal plane, just substitute its configuration into these arrays and you will be able to compute multi-channel pointings.","category":"page"},{"location":"#Falcons","page":"Home","title":"Falcons","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation of Falcons(Fast Algorithm for Locus Computing ON the Sky), a package for fast simulation of satellite observations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CMB polarimetric satellites such as LiteBIRD set up an appropriate scan strategy to reduce systematic errors, and Falcons can calculate all-sky hit maps, crosslink maps, etc. by simply setting the parameters of this scan strategy. It also supports observations with multi-channel detectors.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From the Julia REPL, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"Falcons\")","category":"page"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The tutorial is available on the github page in jupyternotebook format. Please refer to here.","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The documentation was built using Documenter.jl.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/#Scanning-strategy","page":"-","title":"Scanning strategy","text":"","category":"section"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"To define the scanning strategy for a satellite, set the ScanningStrategy structure.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"mutable struct ScanningStrategy{T<:AbstractFloat, I<:Int, AA<:AbstractArray{T}, AS<:AbstractString}\n    nside::I\n    times::I\n    sampling_rate::I\n    alpha::T\n    beta::T\n    prec_period::T\n    spin_rpm::T\n    hwp_rpm::T\n    FP_theta::AA\n    FP_phi::AA\n    start_point::AS\nend","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"You can generate ScanningStrategy structure using gen_ScanningStrategy() function.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"ss = gen_ScanningStrategy()","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"The initial value of ss is automatically set to the following value.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"ss.nside = 128,\nss.duration = 31536000, #[sec.]\nss.sampling_rate = 1, #[Hz]\nss.alpha = 45.0, #[deg.]\nss.beta = 50.0, #[deg.]\nss.prec_rpm = 0.005, #[rpm]\nss.spin_rpm = 0.01, #[rpm]\nss.hwp_rpm = 0.0, #[rpm]\nss.FP_theta = [0.0], #[deg.]\nss.FP_phi[0.0], #[deg.]\nss.start_point = \"equator\" #or \"pole\"","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"This initial value can be changed by specifying the gen_ScanningStrategy() argument when declaring ss like below.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"ss = gen_ScanningStrategy(alpha=60, prec_rpm=0.001, sampling_rate=5)","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"In addition, you can directly access ss and interactively change its value.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"ss.nside = 256 #You can change a value\nss.spin_rpm = 0.04","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/#Generate-pointing-TOD","page":"-","title":"Generate pointing TOD","text":"","category":"section"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"The information about the orientation of a satellite at a certain time is called pointing. The pointing is defined by (theta phi psi), where theta and phi are parameters of the 3D polar coordinates and psi is the angle between the scan direction and the meridian of the sky.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"Once the scanning strategy is determined, computing the pointing is straightforward.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"pointings = get_pointings(ss::ScanningStrategy, start::Int, stop::Int)\npix_tod, psi_tod, time_array = get_pointing_pixels(ss::ScanningStrategy, start::Int, stop::Int)","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"Enter an integer value for the time to be calculated in the start and stop fields. The get_pointings() returns (theta phi psi) that indicate their pointing in chronological order. These are stored as an array of dictionary type, and can be accessed as follows.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"In[]: pointings[\"theta\"]\nOut[]: 14400×1 Matrix{Float64}:\n 1.1344640137963142\n 1.134461356131033\n 1.1344533831585348\n 1.1344400949488544\n...","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"The pointings[\"psi\"] contains the scanning angle according to the COSMO(HEALPix) definition. And pointings[\"time\"] contains the time used in the calculation.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"The get_pointing_pixels() does not allocate theta and phi arrays internally, but only allocates the minimum number of arrays needed to allocate the pixel TOD. Therefore, it runs faster than get_pointings(). In fact, get_pointing_pixels() is executed inside ScanningStrategy2map().","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"Now, the pointing TOD is calculated every month and stored in the map each time.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"ss.FP_theta = [0.0, 10.0]\nss.FP_phi = [0.0, 90.0]","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"In this operation, the first component of the array represents the center of the focal plane, i.e. the boresight. On the other hand, the second component represents the detector that observes a point in the sky 10 degrees in theta direction and 90 degrees in phi direction away from the boresight.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"If you want to build a focal plane, just substitute its configuration into these arrays and you will be able to compute multi-channel pointings.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/#Scanning-strategy-with-half-wave-plate","page":"-","title":"Scanning strategy with half-wave plate","text":"","category":"section"}]
}
